\chapter{Implementation}
\label{chap:implementation}

This chapter will focus on implementation details of the pipelines. It will cover the pipeline framework

Having decided to focus on Fourier domain approaches, the two obvious candidates to implement are both \citeauthor{Reddy1996}'s and \citeauthor{Hurtos2015}'s pipelines. There are some modifications, improvements and optimizations that have been made to the basic implementations and will be presented in the following sections.

Additionally, a few restrictions/assumptions are set:

\begin{itemize}
    \item All the frames should have the same range and number of beams. 
    \item The drone is assumed to never change its diving depth.
\end{itemize}

The pipelines

\section{A small comment on pipelines and code}

\begin{figure}[H] 
  \centering
  \includegraphics[width=.5\textwidth]{figures/Module.png}
  \caption{A Module, the main building block of a pipeline.}
\end{figure}

Since the pipelines are composed of mostly independent modules that operate on two input images and in some cases its mask, a flexible framework has been designed to model this behaviour. A \textit{pipeline} contains a sequence of modules that by default are fed the output of the preceding one. This behavior can be modified to suit the pipeline's needs by specifying the id of the module whose output will be chosen as input. Pipelines themselves can be used as modules to organize the code better. A small example of the syntax used for the registration section of the Fourier-Mellin Pipeline is shown below:

\begin{lstlisting}[
    caption={Example of pipeline definition},
    label=lst:pipeline-definition,
    language=Python]
registration_id, registration = Pipeline('registration')
start_id, _ = registration.add_module(IdentityModule())
registration.add_module(FourierModule())
registration.add_module(LogPolarModule(order=1))
registration.add_module(PhaseCorrelationModule(10, 'rotation'))
registration.add_module(IdentityModule(), input_stage=start_id)
registration.add_module(WarpModule(), apply_to=('b', 'm'))
registration.add_module(PhaseCorrelationModule(10, 'translation'))
\end{lstlisting}

The \lstinline{add_module} method on the pipeline allows us to specify a module, the input stage, and to which of the inputs apply the functionality. The reroute-able inputs work by caching the output of each module in the pipeline itself. If rerouting is specified, the pipeline will use these cached values instead of using the output of the previous module. In addition the pipeline itself, on initialization, can take arguments to aid in debugging by printing the output of the pipeline at that stage. It is the hope that this will make it easier to iterate on or modify the code by swapping out modules or extending pipelines. All this functionality however, comes with the additional cost in memory to hold the cached values of the pipeline during the cycle. A fully optimized, monolithic pipeline would be more efficient and might be the right step when working towards implementing this in the \acrshort{rov}, however this approach offers the flexibility needed during this experimentation phase.

In most cases the modules perform the same operations on the inputs, in which case it would be advantageous to perform these tasks in parallel. To simplify the implementation of parallelization, the modules use \texttt{Ray} from Anyscale, Inc. Processing only on the CPU is not the most efficient, but by parallelizing the pipeline where possible some speedup can be gained.

Parallelization using \texttt{Ray} is done using \texttt{Tasks}. These turn static methods into asynchronously executable functions, ideally helping us to halve the time it takes to execute a module. In essence, any static function is a candidate for this. Note the \lstinline{@ray.remote} in the following example of a module using \texttt{Ray}:

\begin{lstlisting}[
    caption={Example of pipeline parallelization},
    label=lst:pipeline-parallelization,
    language=Python]
class BandpassModule(PipelineModule):
    def __init__(self, low_cutoff, high_cutoff):
        super().__init__()
        self.low_cutoff = low_cutoff
        self.high_cutoff = high_cutoff

    @staticmethod
    @ray.remote
    def bandpass(data, low_cutoff, high_cutoff):
        if data is None:
            return None
        return difference_of_gaussians(data, low_cutoff, high_cutoff)

    def run(self, a, b, mask, tform, error):
        a = self.bandpass.remote(a, self.low_cutoff, self.high_cutoff)
        b = self.bandpass.remote(b, self.low_cutoff, self.high_cutoff)
        return ray.get(a), ray.get(b), mask, tform, error
\end{lstlisting}

\section{\citeauthor{Reddy1996}'s Fourier-Mellin Pipeline (adapted) \cite{Reddy1996}}
\label{sec:fmpipeline}
\begin{figure}[H] 
  \centering
  \includegraphics[width=.7\textwidth]{figures/fourier_mellin_pipeline.png}
  \caption{Block diagram of the Fourier-Mellin registration pipeline (adapted).}
  \label{fig:fmpipeline}
\end{figure}

The Fourier-Mellin Pipeline has been adapted to suit sonar images in a total of 10 independent modules. The main adaptation is the addition of the first block of modules (Resizing, Fan Transformation and Padding) which allows the Fourier-Mellin Pipeline to work on sonar images. Note that most of them are fed their inputs sequentially, except for the Warp Module which applies the detected rotation to the masked image so that the translation could be identified. Here, the flexibility of the pipeline framework implementation shines. The next sections will go into more detail about how each module is implemented. 

\begin{lstlisting}[
    caption={Fourier-Mellin Pipeline Implementation},
    label=lst:fm-pipeline-code,
    language=Python]
pipeline = Pipeline(output=args.out, 
                    intermediate_output=args.intermediate_output, 
                    verbose=args.verbose)
pipeline.add_module(IdentityModule())
conditioning_id, conditioning = pipeline.add_module(Pipeline('conditioning'))
conditioning.add_module(ResizeModule(args.resize))
conditioning.add_module(FanModule(bearings, output=args.out))
conditioning.add_module(PaddingModule(0.25))

pipeline.add_module(MetricsModule(output=args.out))

filtering_id, filtering = pipeline.add_module(Pipeline('filtering'))
filtering.add_module(BandpassModule(args.bandpass_low, args.bandpass_high))
filtering.add_module(MaskModule(padding=60, sigma=15))

registration_id, registration = pipeline.add_module(Pipeline('registration'))
start_id, _ = registration.add_module(IdentityModule())
registration.add_module(FourierModule())
registration.add_module(LogPolarModule(order=1))
registration.add_module(PhaseCorrelationModule(10, 'rotation'))
registration.add_module(IdentityModule(), input_stage=start_id)
registration.add_module(WarpModule(), apply_to=('b', 'm'))
registration.add_module(PhaseCorrelationModule(10, 'translation'))

pipeline.add_module(UpdateTformModule(range_resolution=range_resolution))
pipeline.add_module(IdentityModule(), ('a', 'b'), input_stage=conditioning_id)
pipeline.add_module(WarpModule(combine=True), 'b')
pipeline.add_module(OdometerModule(output=args.out, 
                                   range_resolution=range_resolution))
\end{lstlisting}

\section{\citeauthor{Hurtos2015} Pipeline \cite{Hurtos2015}}
\begin{figure}[H] 
  \centering
  \includegraphics[width=.7\textwidth]{figures/reddy_pipeline.png}
  \caption{Block diagram of \citeauthor{Hurtos2015}'s Pipeline (adapted).}
  \label{fig:pcpipeline}
\end{figure}

With 9 modules \citeauthor{Hurtos2015}'s Pipeline isn't much shorter on first inspection. On a closer look however, it is evident that some of the heavyweight modules from the Fourier-Mellin pipeline are missing: Fourier Transform and the Log-Polar transform. As mentioned before, performing Phase Correlation over the raw polar image although faster and valid for short rotations, might not perform so well on distant frames. This is because the rotations isn't decoupled from translations in the raw sonar frame. Given the frequency of sonar frames coming from the \acrshort{bsosonar} (see \autoref{tab:sonar_specs}) and the max speed of the drone (see \autoref{tab:drone_specs}, we can assume that translations will be very small. At \(10Hz\) there is \(0.1s\) between frames. At \(1.5m/s\) the maximum movement between frames would be \(0.15m\). This is a small value indeed, but gets even smaller when considering that the drone is observing the seabed at significant distance. 

\begin{lstlisting}[
    caption={\citeauthor{Hurtos2015} Pipeline Implementation},
    label=lst:pc-pipeline-code,
    language=Python]
pipeline = Pipeline(output=args.out, 
                    intermediate_output=args.intermediate_output, 
                    verbose=args.verbose)
registration_id, registration = pipeline.add_module(Pipeline('registration'))
registration.add_module(ResizeModule(args.resize))
resize_id, _ = registration.add_module(IdentityModule())
registration.add_module(MaskModule(padding=60, sigma=15))
registration.add_module(PhaseCorrelationModule(20, 'rotation', log_polar=False))
registration.add_module(FanModule(bearings, output=args.out), input_stage=resize_id)
padding_id, _ = registration.add_module(PaddingModule(0.25))
registration.add_module(BandpassModule(args.bandpass_low, args.bandpass_high))
registration.add_module(MaskModule(padding=60, sigma=15))
registration.add_module(WarpModule(), apply_to=('b', 'm'))
registration.add_module(PhaseCorrelationModule(10, 'translation'))
pipeline.add_module(UpdateTformModule())
pipeline.add_module(IdentityModule(), ('a', 'b'), input_stage=pipeline.name)
pipeline.add_module(OdometerModule(output=args.out, 
                                   range_resolution=range_resolution))
pipeline.add_module(IdentityModule(), input_stage=padding_id)
pipeline.add_module(WarpModule(combine=True), 'b')
\end{lstlisting}



\section{Pre-processing pipelines' modules}

Many modules are used in both pipelines and are worth mentioning here.
\begin{itemize}
    \item Resizing: mainly down-sampling, is essential for speeding up the processing pipeline as it reduces the computations needed down the line. Often the starting point of the pipeline. Taking as input a resizing ratio \(R\) it calculates the expected size of the resized image and re-scales it appropriately. Down-sampling with an anti-aliasing filter also also reduces noise, another positive side-effect of this module.
    \item Padding: necessary for keeping the sonar image in frame once the rotation is applied. A black border is added to the image to keep the relevant data in frame.
    \item Filtering: it is recommended to apply some degree of band-pass filtering focusing in particular on high frequency noise.
    \item Masking: the images should be windowed to have smooth borders to avoid spectral leakage from the image borders. This module applies some gaussian filtering to the current mask and applies it to the input images. This makes the image have a smoother transition from the border to the data.
\end{itemize}


\subsection{Resizing (down-sampling)}

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Original.png}
        \caption{Raw data obtained from the sonar}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Resized.png}
        \caption{Resized frame}
    \end{subfigure}
    \caption{Down-sampled image}
    \label{fig:resizing}
\end{figure}

Resizing the images is necessary to make the pipelines in consideration less computationally expensive. This is a "low hanging fruit" optimization that yields visible results. This module takes images of size \((w, h)\) and re-scales them to \((w^*, h^*)\), given a resizing ratio \(R\) where:

\[w^* = w\sqrt{R}\]
\[h^* = h\sqrt{R}\]

In code this is achieved using the \texttt{skimage.transform.resize} package using:

\begin{lstlisting}[
    caption={Resizing code},
    label=lst:pipeline-resizing,
    language=Python]
ratio = np.sqrt(R)
img = resize(img.copy(), 
             (int(img.shape[0] * ratio), int(img.shape[1] * ratio)), 
             anti_aliasing=True)
\end{lstlisting}

The \lstinline{anti_aliasing=True} is necessary to avoid the introduction of aliasing artifacts through down-sampling. Down-sampling an image has the secondary function of acting as a kind of averaging filter which will also work towards reducing the noise in the image. 

Later on, in the results section, the speedup resulting from down-sampling of the image will be evaluated. It is also important to mention that since operations are done independently on each input image, this is a perfect candidate for parallelization over its inputs with \texttt{Ray}.

\subsection{Padding}

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Fan.png}
        \caption{Input fan frame}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Padding.png}
        \caption{Padded fan frame}
    \end{subfigure}
    \caption{Padded image}
    \label{fig:resizing}
\end{figure}

Especially necessary for images that have undergone their Fan Transformation and will be rotated. Any rotation applied to the image might make some of its data go beyond the edges. Adding some padding ensures that all the sonar data remains inside the image. The module takes in a padding ratio \(r\) and pads the image with a black border with a width of \(r * max(widht, height)\). By default, the padding ratio is chosen to be \texttt{0.25}. Smaller values could be chosen, but this may affect registration of distant frames. Choosing this parameter depends on two things: how distant the frames are (big rotations and translations) and the computational impact of more pixels downstream in the pipeline.

In code this is implemented using numpy as:
\begin{lstlisting}[
    caption={Padding code},
    label=lst:pipeline-padding,
    language=Python]
pad_size = int(np.max(img.shape) * self.padding_ratio)
np.pad(data, pad_size, mode='constant', constant_values=0)
\end{lstlisting}

Again, since there are no dependecies between the images, this is a perfect candidate for parallelization using \texttt{Ray}.

\section{Filtering}

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Padding.png}
        \caption{Input padded fan frame}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Bandpass.png}
        \caption{Band-passed padded fan frame}
    \end{subfigure}
    \caption{Band-passed image}
    \label{fig:resizing}
\end{figure}

If required by the pipeline, a band-pass filter has been implemented using \acrfull{dog}. This is a spatial-domain band-pass filter that also works as a feature enhancement algorithm. The filter generates two blurred versions of the original using Gaussian blur, where one of the images is more blurred than the other. The output results from subtracting the more blurry image from the less blurry one. It can enhance edges and other details present in the image while attenuating the noise, making it perfect for image registration.

The \acrshort{dog} takes two parameters \(\sigma_{low}\) and \(\sigma_{high}\). Choosing these values was done qualitatively to include some blurring and maximize contrast with features in the image.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/0_10.png}
        \caption{\(\sigma_{low} = 0\) \(\sigma_{high} = 10\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/0_15.png}
        \caption{\(\sigma_{low} = 0\) \(\sigma_{high} = 15\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/0_20.png}
        \caption{\(\sigma_{low} = 0\) \(\sigma_{high} = 20\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/1_10.png}
        \caption{\(\sigma_{low} = 1\) \(\sigma_{high} = 10\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/1_15.png}
        \caption{\(\sigma_{low} = 1\) \(\sigma_{high} = 15\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/1_20.png}
        \caption{\(\sigma_{low} = 1\) \(\sigma_{high} = 20\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/2_10.png}
        \caption{\(\sigma_{low} = 2\) \(\sigma_{high} = 10\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/2_15.png}
        \caption{\(\sigma_{low} = 2\) \(\sigma_{high} = 15\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/2_20.png}
        \caption{\(\sigma_{low} = 2\) \(\sigma_{high} = 20\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/3_10.png}
        \caption{\(\sigma_{low} = 3\) \(\sigma_{high} = 10\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/3_15.png}
        \caption{\(\sigma_{low} = 3\) \(\sigma_{high} = 15\)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/bandpassing/3_20.png}
        \caption{\(\sigma_{low} = 3\) \(\sigma_{high} = 20\)}
    \end{subfigure}
    \caption{Choosing \(\sigma_{low}\) and \(\sigma_{high}\) values for band-passing}
    \label{fig:resizing}
\end{figure}

Combination \(\sigma_{low} = 2\) \(\sigma_{high} = 20\) is chosen as it accentuates contrast between empty background and features without losing too much detail in the blurring. It's very hard to justify why these parameters would best quantitatively. The metric to go to in this case would be \acrfull{snr}. However this is impossible to calculate without having a reference "true" signal. These parameters can be changed easily from the \acrshort{cli} if desired. In code this filter is implemented through the \texttt{skimage.filters.difference\_of\_gaussians} package:

\begin{lstlisting}[
    caption={Bandpassing code},
    label=lst:pipeline-bandpassing,
    language=Python]
difference_of_gaussians(img, low_sigma, high_sigma)
\end{lstlisting}

Once more, this is a perfect candidate for parallelization using \texttt{Ray}.

\subsection{Masking}

As mentioned before, when applying a discrete Fourier transform if the input isn't periodic this might result in "spectral leakage". This shows up as random frequencies that aren't really part of the input. To avoid this, some windowing of the image is required. As part of the inputs of the pipeline a mask is provided which might be transformed by some of the modules. For example the Fan Transformation Module will convert the rectangular input mask into the fan shape. By default the input mask to the pipeline is an array of ones with the same shape as a sonar frame. The masking module takes the input mask, reduces the size of the masking area while preserving the image size, and applies some gaussian filtering to it with the purpose of smoothing its edges:

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Mask.png}
        \caption{Fan mask}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/MaskBlurred.png}
        \caption{Smoothed \& resized mask}
    \end{subfigure}
    \caption{Smoothing the mask}
    \label{fig:mask-smoothing}
\end{figure}

A padding of \texttt{60px} on every side was chosen as after resizing back to the orignal image size, it makes the blurred border fit completely inside the original mask. In code this is implemented using \texttt{numpy}, \texttt{scipy.ndimage.gaussian\_filter} and \texttt{skimage.transform.resize}:

\begin{lstlisting}[
    caption={Smoothed mask code},
    label=lst:pipeline-masking-smoothing,
    language=Python]
# Add black border
padding = 60
mask = np.pad(input_mask, padding, mode='constant', constant_values=0)
# Resize mask to orignal size
mask = resize(mask, input_mask.shape, anti_aliasing=True)
# Gaussian blur the mask
mask = gaussian_filter(mask, sigma=self.sigma)
\end{lstlisting}

Another optimization takes place here. Instead of recalculating this mask for every incoming frame, the mask is cached and reused in the future. The caching implementation is very simple so the restriction of all frames being the same size still applies. This mask is then applied to the input frames to reduce the visibility of the border of the sonar frame:

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Bandpass.png}
        \caption{Unmasked frame}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Masking.png}
        \caption{Masked frame}
    \end{subfigure}
    \caption{Applying the mask}
    \label{fig:mask-smoothing}
\end{figure}

Using \texttt{numpy} this can be easily achieved through element-wise multiplication: \lstinline{image * mask}. Yet again, except for the calculation of the mask the first time the module runs, this is a perfect candidate for parallelization using \texttt{Ray}.

\section{Fan Transformation}
One of the main modules is definitely the Fan Transformation Module. The raw data from the sensor is structured in an array that represents ping intensity at a specific bearing and range. It is important to note that the beam bearings are not evenly spaced. The sensor provides a table that accompanies the ping information with the specific angle associated with each ping. All of this data is obtained through recording files stored on the \acrshort{rov}. These files contain the sonar data packed in a "Protocol Buffers" format specified by Blueye's Protocol Definitions \cite{Blueye:ProtocolDefinitions}. The following is an example "MultibeamPing" message:

\begin{lstlisting}[
    caption={Example MultibeamPing message},
    label=lst:ping-protobuf]
ping {
  range: 30.758804321289062
  gain: 100.0
  frequency: 1196808.5106382978
  speed_of_sound_used: 1517.4982581645493
  frequency_mode: MULTIBEAM_FREQUENCY_MODE_LOW_FREQUENCY
  number_of_ranges: 378
  number_of_beams: 512
  step: 512
  bearings: -65.0
  bearings: -64.5199966430664
  ...
  bearings: 64.5199966430664
  bearings: 65.0
  ping_data: [1D array containing sonar image]
  device_id: GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M1200D
}
\end{lstlisting}

The \lstinline{ping_data} is produced as a continuous 1D array that must be reshaped in order to work with it as an image. Using the \lstinline{number_of_ranges} and \lstinline{number_of_beams} we can convert the 1D-array into a 2D one. Using the equations from \ref{sec:fan-tform} and the bearing table provided by the MultibeamPing record, the fan transformation can be implemented as a module in the pipelines. 

A huge optimization can be performed here. Given the restriction that all the frames should have the same range and number of beams, the mapping can be pre-computed for all images and cached for use on all the incoming frames. This saves cpu cycles on performing all the possible \((u, v) \rightarrow (\theta,r)\) calculations. The effect of this speedup will be evaluated in the following sections.

Range resolution depends on the sonar, in our case 2.5mm per pixel along the range axis \ref{tab:sonar_specs}. It allows us to convert simple pixel values into real world coordinates. In most cases, a simple division of \lstinline{range} over \lstinline{number_of_ranges} will give us this value. However, it is often the case that to speed up processing images are resized. If the image is scaled a simple calculation can compensate for this change. Given \(R\) as the resizing ratio for the image area, the resizing ratio for a dimension of the image will be given by \(\sqrt{R}\). The new range resolution can be calculated with the following equation:

\[rangeResolution = \frac{range}{numberOfRanges * \sqrt{R}}\]

This module is yet another example of a candidate for parallelization using \texttt{Ray}.

\section{Registration Modules}



\subsection{\acrfull{fft}}

A simple module that applies the \acrshort{fft} to incoming inputs. The \acrshort{fft} is an algorithm that implements the Discrete Fourier Transform efficiently. The result of the transform is a signal in the complex domain (composed of Real and Imaginary parts). Decomposition into magnitude and phase makes it easier to visualize, and as mentioned previously in \autoref{sec:fm-registration} we're only interested in the magnitude for rotation estimation using \citeauthor{Reddy1996}'s Fourier-Mellin Pipeline. Using \texttt{numpy} we can get the magnitude of the \acrshort{fft} and center the zero-frequency component with: \lstinline{np.abs(np.fft.fftshift(np.fft.fft2(image)))}. This results in the following transformation:

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/Masking.png}
        \caption{Masked frame}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/pipeline/FFT.png}
        \caption{FFT}
    \end{subfigure}
    \caption{Fourier transform}
    \label{fig:fft}
\end{figure}


\subsection{Log-Polar Transform}

\subsection{Phase Correlation}

\section{Mosaicing}